// Risk Validation Service
// Implements human-in-the-loop validation workflows for TI-enhanced risks

export interface RiskValidation {
  id?: number;
  risk_id: number;
  validator_id: number;
  validation_type: 'automated' | 'manual' | 'hybrid';
  validation_status: 'pending' | 'approved' | 'rejected' | 'needs_info';
  validation_notes: string;
  confidence_score?: number;
  validation_timestamp?: string;
  created_at?: string;
}

export interface ValidationWorkflowConfig {
  auto_approve_threshold: number; // Confidence score threshold for auto-approval
  require_dual_validation: boolean; // Require two validators for high-impact risks
  escalation_timeout_hours: number; // Hours before escalation
  validation_categories: string[]; // Risk categories requiring validation
}

export interface ValidationMetrics {
  pending_validations: number;
  approved_today: number;
  rejected_today: number;
  avg_validation_time_hours: number;
  validator_workload: Array<{
    validator_id: number;
    pending_count: number;
    completed_today: number;
  }>;
  validation_accuracy: number; // % of validations that remain stable
}

export class RiskValidationService {
  private db: D1Database;
  private config: ValidationWorkflowConfig;

  constructor(db: D1Database, config?: Partial<ValidationWorkflowConfig>) {
    this.db = db;
    this.config = {
      auto_approve_threshold: 0.9,
      require_dual_validation: true,
      escalation_timeout_hours: 24,
      validation_categories: ['cybersecurity', 'compliance'],
      ...config
    };
  }

  /**
   * Submit risk for validation
   */
  async submitForValidation(riskId: number): Promise<RiskValidation> {
    try {
      // Get risk details
      const risk = await this.db.prepare(`
        SELECT * FROM risks WHERE id = ?
      `).bind(riskId).first();

      if (!risk) {
        throw new Error(`Risk ${riskId} not found`);
      }

      // Check if validation is required based on category and config
      if (!this.config.validation_categories.includes(risk.category as string)) {
        // Auto-approve if not in validation categories
        await this.autoApproveRisk(riskId, 'Category exemption');
        throw new Error(`Risk category '${risk.category}' does not require validation`);
      }

      // Check for auto-approval based on confidence
      const confidence = await this.calculateRiskConfidence(risk);
      if (confidence >= this.config.auto_approve_threshold) {
        return await this.autoApproveRisk(riskId, `Auto-approved: confidence ${confidence.toFixed(2)}`);\n      }\n\n      // Find appropriate validator\n      const validatorId = await this.assignValidator(risk);\n\n      // Create validation record\n      const result = await this.db.prepare(`\n        INSERT INTO risk_validations (\n          risk_id, validator_id, validation_type, validation_status, \n          validation_notes, confidence_score\n        ) VALUES (?, ?, ?, ?, ?, ?)\n      `).bind(\n        riskId, \n        validatorId, \n        'manual', \n        'pending',\n        `Submitted for validation - confidence: ${confidence.toFixed(2)}`,\n        confidence\n      ).run();\n\n      // Update risk status\n      await this.db.prepare(`\n        UPDATE risks SET \n          validation_status = 'pending',\n          risk_lifecycle_stage = 'validation',\n          updated_at = CURRENT_TIMESTAMP\n        WHERE id = ?\n      `).bind(riskId).run();\n\n      const validation: RiskValidation = {\n        id: result.meta?.last_row_id as number,\n        risk_id: riskId,\n        validator_id: validatorId,\n        validation_type: 'manual',\n        validation_status: 'pending',\n        validation_notes: `Submitted for validation - confidence: ${confidence.toFixed(2)}`,\n        confidence_score: confidence,\n        created_at: new Date().toISOString()\n      };\n\n      console.log(`Risk ${riskId} submitted for validation by validator ${validatorId}`);\n      return validation;\n    } catch (error) {\n      console.error('Risk validation submission failed:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Assign validator to risk\n   */\n  async assignValidator(riskOrId: any): Promise<number> {\n    try {\n      const risk = typeof riskOrId === 'object' ? riskOrId : \n        await this.db.prepare('SELECT * FROM risks WHERE id = ?').bind(riskOrId).first();\n\n      if (!risk) {\n        throw new Error('Risk not found for validator assignment');\n      }\n\n      // Get available validators (this would integrate with user/role system)\n      // For now, we'll use a simple round-robin approach\n      const validators = await this.getAvailableValidators();\n      \n      if (validators.length === 0) {\n        throw new Error('No available validators');\n      }\n\n      // Find validator with least workload\n      const workloads = await Promise.all(\n        validators.map(async (validator) => {\n          const pending = await this.db.prepare(`\n            SELECT COUNT(*) as count FROM risk_validations \n            WHERE validator_id = ? AND validation_status = 'pending'\n          `).bind(validator.id).first();\n          \n          return { validator_id: validator.id, pending_count: pending?.count || 0 };\n        })\n      );\n\n      // Select validator with minimum workload\n      const selectedValidator = workloads.reduce((min, current) => \n        current.pending_count < min.pending_count ? current : min\n      );\n\n      return selectedValidator.validator_id;\n    } catch (error) {\n      console.error('Validator assignment failed:', error);\n      // Default to validator ID 1 if assignment fails\n      return 1;\n    }\n  }\n\n  /**\n   * Validate risk (approve/reject)\n   */\n  async validateRisk(validationData: RiskValidation): Promise<RiskValidation> {\n    try {\n      const { risk_id, validation_status, validation_notes, validator_id } = validationData;\n\n      // Update validation record\n      await this.db.prepare(`\n        UPDATE risk_validations SET\n          validation_status = ?,\n          validation_notes = ?,\n          validation_timestamp = CURRENT_TIMESTAMP\n        WHERE risk_id = ? AND validator_id = ?\n      `).bind(validation_status, validation_notes, risk_id, validator_id).run();\n\n      // Update risk based on validation result\n      if (validation_status === 'approved') {\n        await this.db.prepare(`\n          UPDATE risks SET\n            validation_status = 'approved',\n            validator_id = ?,\n            validation_notes = ?,\n            risk_lifecycle_stage = 'validated',\n            updated_at = CURRENT_TIMESTAMP\n          WHERE id = ?\n        `).bind(validator_id, validation_notes, risk_id).run();\n\n        console.log(`Risk ${risk_id} approved by validator ${validator_id}`);\n      } else if (validation_status === 'rejected') {\n        await this.db.prepare(`\n          UPDATE risks SET\n            validation_status = 'rejected',\n            validator_id = ?,\n            validation_notes = ?,\n            status = 'rejected',\n            risk_lifecycle_stage = 'rejected',\n            updated_at = CURRENT_TIMESTAMP\n          WHERE id = ?\n        `).bind(validator_id, validation_notes, risk_id).run();\n\n        console.log(`Risk ${risk_id} rejected by validator ${validator_id}`);\n      } else if (validation_status === 'needs_info') {\n        await this.db.prepare(`\n          UPDATE risks SET\n            validation_status = 'needs_info',\n            validator_id = ?,\n            validation_notes = ?,\n            risk_lifecycle_stage = 'information_needed',\n            updated_at = CURRENT_TIMESTAMP\n          WHERE id = ?\n        `).bind(validator_id, validation_notes, risk_id).run();\n\n        console.log(`Risk ${risk_id} requires additional information - validator ${validator_id}`);\n      }\n\n      // Return updated validation\n      const updatedValidation = await this.db.prepare(`\n        SELECT * FROM risk_validations \n        WHERE risk_id = ? AND validator_id = ?\n        ORDER BY created_at DESC LIMIT 1\n      `).bind(risk_id, validator_id).first();\n\n      return updatedValidation as RiskValidation;\n    } catch (error) {\n      console.error('Risk validation failed:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Get validation queue for validator\n   */\n  async getValidationQueue(validatorId?: number): Promise<any[]> {\n    try {\n      let query = `\n        SELECT \n          r.id, r.title, r.description, r.category, r.likelihood, r.impact,\n          r.risk_score, r.ti_enriched, r.epss_score, r.cvss_score,\n          r.risk_lifecycle_stage, r.created_at,\n          rv.id as validation_id, rv.validation_type, rv.confidence_score,\n          rv.created_at as validation_created_at\n        FROM risks r\n        JOIN risk_validations rv ON r.id = rv.risk_id\n        WHERE rv.validation_status = 'pending'\n      `;\n\n      const params: any[] = [];\n      \n      if (validatorId) {\n        query += ' AND rv.validator_id = ?';\n        params.push(validatorId);\n      }\n\n      query += ` \n        ORDER BY \n          CASE WHEN r.ti_enriched = TRUE THEN 1 ELSE 2 END,\n          r.risk_score DESC,\n          rv.created_at ASC\n      `;\n\n      const results = await this.db.prepare(query).bind(...params).all();\n      return results.results || [];\n    } catch (error) {\n      console.error('Getting validation queue failed:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Escalate validation (timeout or complex cases)\n   */\n  async escalateValidation(riskId: number, reason: string): Promise<void> {\n    try {\n      // Find senior validator or use escalation queue\n      const seniorValidatorId = await this.findSeniorValidator();\n\n      // Create escalation record\n      await this.db.prepare(`\n        INSERT INTO risk_validations (\n          risk_id, validator_id, validation_type, validation_status,\n          validation_notes\n        ) VALUES (?, ?, ?, ?, ?)\n      `).bind(\n        riskId,\n        seniorValidatorId,\n        'manual',\n        'pending',\n        `ESCALATED: ${reason}`\n      ).run();\n\n      // Update risk status\n      await this.db.prepare(`\n        UPDATE risks SET\n          risk_lifecycle_stage = 'escalated',\n          validation_notes = ?,\n          updated_at = CURRENT_TIMESTAMP\n        WHERE id = ?\n      `).bind(`ESCALATED: ${reason}`, riskId).run();\n\n      console.log(`Risk ${riskId} escalated: ${reason}`);\n    } catch (error) {\n      console.error('Risk validation escalation failed:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Get validation metrics and statistics\n   */\n  async getValidationMetrics(): Promise<ValidationMetrics> {\n    try {\n      // Get pending validations count\n      const pendingResult = await this.db.prepare(`\n        SELECT COUNT(*) as count FROM risk_validations \n        WHERE validation_status = 'pending'\n      `).first();\n\n      // Get today's approved/rejected counts\n      const todayResult = await this.db.prepare(`\n        SELECT \n          SUM(CASE WHEN validation_status = 'approved' THEN 1 ELSE 0 END) as approved,\n          SUM(CASE WHEN validation_status = 'rejected' THEN 1 ELSE 0 END) as rejected\n        FROM risk_validations \n        WHERE DATE(validation_timestamp) = DATE('now')\n      `).first();\n\n      // Get average validation time\n      const avgTimeResult = await this.db.prepare(`\n        SELECT AVG(\n          (julianday(validation_timestamp) - julianday(created_at)) * 24\n        ) as avg_hours\n        FROM risk_validations \n        WHERE validation_timestamp IS NOT NULL\n          AND created_at > datetime('now', '-30 days')\n      `).first();\n\n      // Get validator workloads\n      const workloadResults = await this.db.prepare(`\n        SELECT \n          validator_id,\n          SUM(CASE WHEN validation_status = 'pending' THEN 1 ELSE 0 END) as pending_count,\n          SUM(CASE WHEN DATE(validation_timestamp) = DATE('now') THEN 1 ELSE 0 END) as completed_today\n        FROM risk_validations\n        GROUP BY validator_id\n        ORDER BY pending_count DESC\n      `).all();\n\n      return {\n        pending_validations: pendingResult?.count as number || 0,\n        approved_today: todayResult?.approved as number || 0,\n        rejected_today: todayResult?.rejected as number || 0,\n        avg_validation_time_hours: Math.round((avgTimeResult?.avg_hours as number || 0) * 100) / 100,\n        validator_workload: (workloadResults.results || []).map((row: any) => ({\n          validator_id: row.validator_id,\n          pending_count: row.pending_count,\n          completed_today: row.completed_today\n        })),\n        validation_accuracy: 0.95 // Placeholder - would calculate from historical data\n      };\n    } catch (error) {\n      console.error('Getting validation metrics failed:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Auto-check for validations requiring escalation\n   */\n  async checkEscalationNeeds(): Promise<void> {\n    try {\n      const timeoutHours = this.config.escalation_timeout_hours;\n      \n      const overdueValidations = await this.db.prepare(`\n        SELECT rv.risk_id, rv.validator_id, r.title\n        FROM risk_validations rv\n        JOIN risks r ON rv.risk_id = r.id\n        WHERE rv.validation_status = 'pending'\n          AND rv.created_at < datetime('now', '-${timeoutHours} hours')\n      `).all();\n\n      for (const validation of (overdueValidations.results || [])) {\n        await this.escalateValidation(\n          validation.risk_id as number, \n          `Timeout after ${timeoutHours} hours`\n        );\n      }\n\n      if (overdueValidations.results?.length) {\n        console.log(`Escalated ${overdueValidations.results.length} overdue validations`);\n      }\n    } catch (error) {\n      console.error('Escalation check failed:', error);\n    }\n  }\n\n  /**\n   * Private helper methods\n   */\n\n  private async calculateRiskConfidence(risk: any): Promise<number> {\n    let confidence = 0.5; // Base confidence\n\n    // TI enrichment increases confidence\n    if (risk.ti_enriched) {\n      confidence += 0.3;\n      \n      // High EPSS/CVSS scores increase confidence\n      if (risk.epss_score && risk.epss_score > 0.7) confidence += 0.1;\n      if (risk.cvss_score && risk.cvss_score > 8.0) confidence += 0.1;\n    }\n\n    // Structured data increases confidence\n    if (risk.category && risk.likelihood && risk.impact) {\n      confidence += 0.1;\n    }\n\n    // Recent detection increases confidence\n    const createdAt = new Date(risk.created_at);\n    const hoursOld = (Date.now() - createdAt.getTime()) / (1000 * 60 * 60);\n    if (hoursOld < 24) confidence += 0.05;\n\n    return Math.min(confidence, 1.0);\n  }\n\n  private async autoApproveRisk(riskId: number, reason: string): Promise<RiskValidation> {\n    // Create auto-approval validation record\n    const result = await this.db.prepare(`\n      INSERT INTO risk_validations (\n        risk_id, validator_id, validation_type, validation_status,\n        validation_notes, confidence_score, validation_timestamp\n      ) VALUES (?, ?, ?, ?, ?, ?, CURRENT_TIMESTAMP)\n    `).bind(\n      riskId, 0, 'automated', 'approved', reason, this.config.auto_approve_threshold\n    ).run();\n\n    // Update risk\n    await this.db.prepare(`\n      UPDATE risks SET\n        validation_status = 'approved',\n        risk_lifecycle_stage = 'validated',\n        validation_notes = ?,\n        updated_at = CURRENT_TIMESTAMP\n      WHERE id = ?\n    `).bind(reason, riskId).run();\n\n    return {\n      id: result.meta?.last_row_id as number,\n      risk_id: riskId,\n      validator_id: 0,\n      validation_type: 'automated',\n      validation_status: 'approved',\n      validation_notes: reason,\n      confidence_score: this.config.auto_approve_threshold,\n      validation_timestamp: new Date().toISOString(),\n      created_at: new Date().toISOString()\n    };\n  }\n\n  private async getAvailableValidators(): Promise<Array<{ id: number; name: string }>> {\n    // This would integrate with user management system\n    // For now, return mock validators\n    return [\n      { id: 1, name: 'Senior Security Analyst' },\n      { id: 2, name: 'Risk Manager' },\n      { id: 3, name: 'Compliance Officer' }\n    ];\n  }\n\n  private async findSeniorValidator(): Promise<number> {\n    // Find the most experienced validator\n    // For now, return validator ID 1\n    return 1;\n  }\n}