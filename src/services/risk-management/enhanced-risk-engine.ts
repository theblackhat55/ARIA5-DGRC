// Enhanced Risk Engine with TI Integration
// Provides comprehensive risk lifecycle management and TI-enhanced analysis

export interface Risk {
  id: number;
  title: string;
  description: string;
  category: string;
  likelihood: string;
  impact: string;
  risk_score: number;
  status: string;
  ti_enriched: boolean;
  ti_sources?: string;
  epss_score?: number;
  cvss_score?: number;
  exploit_status?: string;
  mitigation_timeline?: string;
  risk_lifecycle_stage: string;
  validation_status: string;
  validator_id?: number;
  validation_notes?: string;
  created_at: string;
  updated_at: string;
}

export interface ServiceRiskAssessment {
  id: number;
  service_id: number;
  assessment_date: string;
  overall_risk_score: number;
  cybersecurity_score: number;
  operational_score: number;
  compliance_score: number;
  strategic_score: number;
  ti_enhanced: boolean;
  assessment_notes: string;
  assessor_id?: number;
}

export interface RiskMatrix {
  high_high: Risk[];
  high_medium: Risk[];
  high_low: Risk[];
  medium_high: Risk[];
  medium_medium: Risk[];
  medium_low: Risk[];
  low_high: Risk[];
  low_medium: Risk[];
  low_low: Risk[];
  matrix_metadata: {
    total_risks: number;
    critical_quadrant: number; // high-high
    attention_quadrant: number; // high-medium + medium-high
    monitoring_quadrant: number; // others
    generated_at: string;
  };
}

export class EnhancedRiskEngine {
  private db: D1Database;

  constructor(db: D1Database) {
    this.db = db;
  }

  /**
   * Risk Lifecycle Management
   */

  async detectRisks(): Promise<Risk[]> {
    try {
      // Auto-detect risks from various sources
      const detectedRisks: Risk[] = [];
      
      // 1. Detect from TI indicators
      const tiRisks = await this.detectFromTIIndicators();
      detectedRisks.push(...tiRisks);
      
      // 2. Detect from service anomalies
      const serviceRisks = await this.detectFromServiceAnomalies();
      detectedRisks.push(...serviceRisks);
      
      // 3. Detect from compliance gaps
      const complianceRisks = await this.detectFromComplianceGaps();
      detectedRisks.push(...complianceRisks);
      
      return detectedRisks;
    } catch (error) {
      console.error('Risk detection failed:', error);
      throw error;
    }
  }

  async validateRisk(riskId: number, validatorId: number, validationNotes?: string): Promise<void> {
    try {
      await this.db.prepare(`
        UPDATE risks SET
          validation_status = 'approved',
          validator_id = ?,
          validation_notes = ?,
          risk_lifecycle_stage = 'validated',
          updated_at = CURRENT_TIMESTAMP
        WHERE id = ?
      `).bind(validatorId, validationNotes || '', riskId).run();

      // Log validation
      await this.logRiskActivity(riskId, 'validated', `Risk validated by user ${validatorId}`);\n    } catch (error) {\n      console.error('Risk validation failed:', error);\n      throw error;\n    }\n  }\n\n  async activateRisk(riskId: number): Promise<void> {\n    try {\n      await this.db.prepare(`\n        UPDATE risks SET\n          status = 'active',\n          risk_lifecycle_stage = 'active',\n          updated_at = CURRENT_TIMESTAMP\n        WHERE id = ? AND validation_status = 'approved'\n      `).bind(riskId).run();\n\n      // Log activation\n      await this.logRiskActivity(riskId, 'activated', 'Risk activated and moved to active management');\n    } catch (error) {\n      console.error('Risk activation failed:', error);\n      throw error;\n    }\n  }\n\n  async retireRisk(riskId: number, reason: string): Promise<void> {\n    try {\n      await this.db.prepare(`\n        UPDATE risks SET\n          status = 'retired',\n          risk_lifecycle_stage = 'retired',\n          validation_notes = ?,\n          updated_at = CURRENT_TIMESTAMP\n        WHERE id = ?\n      `).bind(reason, riskId).run();\n\n      // Log retirement\n      await this.logRiskActivity(riskId, 'retired', reason);\n    } catch (error) {\n      console.error('Risk retirement failed:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * TI-Enhanced Risk Analysis\n   */\n\n  async enrichRiskWithTI(riskId: number): Promise<void> {\n    try {\n      // Find related TI indicators\n      const relatedIndicators = await this.findRelatedIndicators(riskId);\n      \n      if (relatedIndicators.length === 0) {\n        return;\n      }\n\n      // Calculate TI-enhanced scores\n      const tiEnhancedScore = this.calculateTIEnhancedScore(relatedIndicators);\n      const maxEpssScore = Math.max(...relatedIndicators.map(i => i.epss_score || 0));\n      const maxCvssScore = Math.max(...relatedIndicators.map(i => i.cvss_score || 0));\n      const tiSources = [...new Set(relatedIndicators.map(i => i.source_id))];\n      \n      // Update risk with TI enrichment\n      await this.db.prepare(`\n        UPDATE risks SET\n          ti_enriched = TRUE,\n          ti_sources = ?,\n          epss_score = ?,\n          cvss_score = ?,\n          risk_score = ?,\n          exploit_status = ?,\n          updated_at = CURRENT_TIMESTAMP\n        WHERE id = ?\n      `).bind(\n        JSON.stringify(tiSources),\n        maxEpssScore || null,\n        maxCvssScore || null,\n        tiEnhancedScore,\n        this.determineExploitStatus(relatedIndicators),\n        riskId\n      ).run();\n\n      // Create risk-TI mappings\n      for (const indicator of relatedIndicators) {\n        await this.createRiskTIMapping(riskId, indicator.id, 0.8);\n      }\n\n      // Log enrichment\n      await this.logRiskActivity(riskId, 'ti_enriched', `Enriched with ${relatedIndicators.length} TI indicators`);\n    } catch (error) {\n      console.error('Risk TI enrichment failed:', error);\n      throw error;\n    }\n  }\n\n  async calculateTIEnhancedScore(indicators: any[]): Promise<number> {\n    if (indicators.length === 0) return 0;\n\n    let maxScore = 0;\n    \n    for (const indicator of indicators) {\n      let score = 0;\n      \n      // Base severity score\n      switch (indicator.severity) {\n        case 'critical': score += 40; break;\n        case 'high': score += 30; break;\n        case 'medium': score += 20; break;\n        case 'low': score += 10; break;\n      }\n\n      // EPSS score contribution\n      if (indicator.epss_score) {\n        score += indicator.epss_score * 30;\n      }\n\n      // CVSS score contribution\n      if (indicator.cvss_score) {\n        score += (indicator.cvss_score / 10) * 20;\n      }\n\n      // Exploit availability bonus\n      if (indicator.exploit_available) {\n        score += 20;\n      }\n\n      // Active exploitation bonus\n      if (indicator.exploit_maturity === 'active') {\n        score += 10;\n      }\n\n      maxScore = Math.max(maxScore, score);\n    }\n\n    return Math.min(maxScore, 100); // Cap at 100\n  }\n\n  async findRelatedIndicators(riskId: number): Promise<any[]> {\n    try {\n      // Get risk details\n      const risk = await this.db.prepare(\n        'SELECT title, description, category FROM risks WHERE id = ?'\n      ).bind(riskId).first();\n\n      if (!risk) return [];\n\n      // Extract search terms from risk\n      const searchTerms = this.extractSearchTerms(risk);\n      const indicators: any[] = [];\n\n      for (const term of searchTerms) {\n        const results = await this.db.prepare(`\n          SELECT * FROM ti_indicators \n          WHERE identifier LIKE ? OR title LIKE ? OR description LIKE ?\n          ORDER BY \n            CASE \n              WHEN severity = 'critical' THEN 4\n              WHEN severity = 'high' THEN 3\n              WHEN severity = 'medium' THEN 2\n              ELSE 1\n            END DESC\n          LIMIT 5\n        `).bind(`%${term}%`, `%${term}%`, `%${term}%`).all();\n\n        indicators.push(...(results.results || []));\n      }\n\n      // Remove duplicates and return top indicators\n      const uniqueIndicators = indicators.filter((indicator, index, self) =>\n        index === self.findIndex(i => i.id === indicator.id)\n      );\n\n      return uniqueIndicators.slice(0, 10); // Limit to top 10 indicators\n    } catch (error) {\n      console.error('Finding related indicators failed:', error);\n      return [];\n    }\n  }\n\n  /**\n   * Service Risk Assessment\n   */\n\n  async assessServiceRisk(serviceId: number): Promise<ServiceRiskAssessment> {\n    try {\n      // Get service details\n      const service = await this.db.prepare(\n        'SELECT * FROM services WHERE id = ?'\n      ).bind(serviceId).first();\n\n      if (!service) {\n        throw new Error(`Service ${serviceId} not found`);\n      }\n\n      // Calculate risk scores by category\n      const cybersecurityScore = await this.calculateCybersecurityRisk(serviceId);\n      const operationalScore = await this.calculateOperationalRisk(serviceId);\n      const complianceScore = await this.calculateComplianceRisk(serviceId);\n      const strategicScore = await this.calculateStrategicRisk(serviceId);\n\n      // Calculate overall score (weighted average)\n      const overallScore = (\n        cybersecurityScore * 0.35 +\n        operationalScore * 0.25 +\n        complianceScore * 0.25 +\n        strategicScore * 0.15\n      );\n\n      // Check if assessment uses TI data\n      const tiEnhanced = cybersecurityScore > 0 && await this.serviceHasTIEnrichment(serviceId);\n\n      // Store assessment\n      const result = await this.db.prepare(`\n        INSERT INTO service_risk_assessments (\n          service_id, assessment_date, overall_risk_score,\n          cybersecurity_score, operational_score, compliance_score, strategic_score,\n          ti_enhanced, assessment_notes\n        ) VALUES (?, DATE('now'), ?, ?, ?, ?, ?, ?, ?)\n      `).bind(\n        serviceId, overallScore, cybersecurityScore, operationalScore,\n        complianceScore, strategicScore, tiEnhanced,\n        `Automated assessment - TI Enhanced: ${tiEnhanced}`\n      ).run();\n\n      const assessment: ServiceRiskAssessment = {\n        id: result.meta?.last_row_id as number,\n        service_id: serviceId,\n        assessment_date: new Date().toISOString().split('T')[0],\n        overall_risk_score: overallScore,\n        cybersecurity_score: cybersecurityScore,\n        operational_score: operationalScore,\n        compliance_score: complianceScore,\n        strategic_score: strategicScore,\n        ti_enhanced: tiEnhanced,\n        assessment_notes: `Automated assessment - TI Enhanced: ${tiEnhanced}`,\n      };\n\n      return assessment;\n    } catch (error) {\n      console.error('Service risk assessment failed:', error);\n      throw error;\n    }\n  }\n\n  async bulkServiceAssessment(): Promise<void> {\n    try {\n      // Get all active services\n      const services = await this.db.prepare(\n        \"SELECT id FROM services WHERE status = 'active'\"\n      ).all();\n\n      console.log(`Starting bulk assessment for ${services.results?.length || 0} services`);\n\n      for (const service of (services.results || [])) {\n        try {\n          await this.assessServiceRisk(service.id as number);\n        } catch (error) {\n          console.error(`Service ${service.id} assessment failed:`, error);\n        }\n      }\n\n      console.log('Bulk service assessment completed');\n    } catch (error) {\n      console.error('Bulk service assessment failed:', error);\n      throw error;\n    }\n  }\n\n  async generateRiskMatrix(): Promise<RiskMatrix> {\n    try {\n      // Get all active risks\n      const risks = await this.db.prepare(`\n        SELECT * FROM risks \n        WHERE status IN ('active', 'draft', 'validated')\n        ORDER BY risk_score DESC, created_at DESC\n      `).all();\n\n      const riskList = (risks.results || []) as Risk[];\n      \n      // Initialize matrix\n      const matrix: RiskMatrix = {\n        high_high: [],\n        high_medium: [],\n        high_low: [],\n        medium_high: [],\n        medium_medium: [],\n        medium_low: [],\n        low_high: [],\n        low_medium: [],\n        low_low: [],\n        matrix_metadata: {\n          total_risks: riskList.length,\n          critical_quadrant: 0,\n          attention_quadrant: 0,\n          monitoring_quadrant: 0,\n          generated_at: new Date().toISOString(),\n        },\n      };\n\n      // Categorize risks into matrix\n      for (const risk of riskList) {\n        const likelihood = this.normalizeLikelihood(risk.likelihood);\n        const impact = this.normalizeImpact(risk.impact);\n        \n        const key = `${likelihood}_${impact}` as keyof Omit<RiskMatrix, 'matrix_metadata'>;\n        matrix[key].push(risk);\n        \n        // Update metadata counters\n        if (key === 'high_high') {\n          matrix.matrix_metadata.critical_quadrant++;\n        } else if (key === 'high_medium' || key === 'medium_high') {\n          matrix.matrix_metadata.attention_quadrant++;\n        } else {\n          matrix.matrix_metadata.monitoring_quadrant++;\n        }\n      }\n\n      return matrix;\n    } catch (error) {\n      console.error('Risk matrix generation failed:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Private Helper Methods\n   */\n\n  private async detectFromTIIndicators(): Promise<Risk[]> {\n    // Auto-detect risks from critical TI indicators\n    const criticalIndicators = await this.db.prepare(`\n      SELECT * FROM ti_indicators \n      WHERE severity = 'critical' AND exploit_available = TRUE\n        AND created_at > datetime('now', '-24 hours')\n    `).all();\n\n    const risks: Risk[] = [];\n\n    for (const indicator of (criticalIndicators.results || [])) {\n      // Check if risk already exists for this indicator\n      const existingRisk = await this.db.prepare(`\n        SELECT r.id FROM risks r\n        JOIN risk_ti_mappings rtm ON r.id = rtm.risk_id\n        WHERE rtm.ti_indicator_id = ?\n      `).bind(indicator.id).first();\n\n      if (!existingRisk) {\n        const risk = await this.createRiskFromTIIndicator(indicator);\n        risks.push(risk);\n      }\n    }\n\n    return risks;\n  }\n\n  private async detectFromServiceAnomalies(): Promise<Risk[]> {\n    // Detect risks from service performance anomalies\n    const anomalousServices = await this.db.prepare(`\n      SELECT * FROM services \n      WHERE risk_score > 70 OR criticality_score > 8\n        AND updated_at > datetime('now', '-12 hours')\n    `).all();\n\n    const risks: Risk[] = [];\n\n    for (const service of (anomalousServices.results || [])) {\n      const risk = await this.createRiskFromServiceAnomaly(service);\n      risks.push(risk);\n    }\n\n    return risks;\n  }\n\n  private async detectFromComplianceGaps(): Promise<Risk[]> {\n    // This would integrate with compliance monitoring systems\n    // For now, return empty array\n    return [];\n  }\n\n  private async createRiskFromTIIndicator(indicator: any): Promise<Risk> {\n    const result = await this.db.prepare(`\n      INSERT INTO risks (\n        title, description, category, likelihood, impact, risk_score,\n        status, ti_enriched, epss_score, cvss_score, exploit_status,\n        risk_lifecycle_stage, validation_status\n      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\n    `).bind(\n      `Critical Vulnerability: ${indicator.identifier}`,\n      `Critical vulnerability detected: ${indicator.description}`,\n      'cybersecurity',\n      'high',\n      'high',\n      85,\n      'draft',\n      true,\n      indicator.epss_score,\n      indicator.cvss_score,\n      indicator.exploit_available ? 'active' : 'potential',\n      'detected',\n      'pending'\n    ).run();\n\n    const riskId = result.meta?.last_row_id as number;\n\n    // Create TI mapping\n    await this.createRiskTIMapping(riskId, indicator.id, 1.0);\n\n    return {\n      id: riskId,\n      title: `Critical Vulnerability: ${indicator.identifier}`,\n      description: `Critical vulnerability detected: ${indicator.description}`,\n      category: 'cybersecurity',\n      likelihood: 'high',\n      impact: 'high',\n      risk_score: 85,\n      status: 'draft',\n      ti_enriched: true,\n      epss_score: indicator.epss_score,\n      cvss_score: indicator.cvss_score,\n      exploit_status: indicator.exploit_available ? 'active' : 'potential',\n      risk_lifecycle_stage: 'detected',\n      validation_status: 'pending',\n      created_at: new Date().toISOString(),\n      updated_at: new Date().toISOString(),\n    };\n  }\n\n  private async createRiskFromServiceAnomaly(service: any): Promise<Risk> {\n    const result = await this.db.prepare(`\n      INSERT INTO risks (\n        title, description, category, likelihood, impact, risk_score,\n        status, risk_lifecycle_stage, validation_status\n      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)\n    `).bind(\n      `Service Performance Anomaly: ${service.name}`,\n      `Performance anomaly detected in service: ${service.name}`,\n      'operational',\n      'medium',\n      service.criticality_score > 8 ? 'high' : 'medium',\n      service.risk_score,\n      'draft',\n      'detected',\n      'pending'\n    ).run();\n\n    const riskId = result.meta?.last_row_id as number;\n\n    return {\n      id: riskId,\n      title: `Service Performance Anomaly: ${service.name}`,\n      description: `Performance anomaly detected in service: ${service.name}`,\n      category: 'operational',\n      likelihood: 'medium',\n      impact: service.criticality_score > 8 ? 'high' : 'medium',\n      risk_score: service.risk_score,\n      status: 'draft',\n      ti_enriched: false,\n      risk_lifecycle_stage: 'detected',\n      validation_status: 'pending',\n      created_at: new Date().toISOString(),\n      updated_at: new Date().toISOString(),\n    };\n  }\n\n  private async calculateCybersecurityRisk(serviceId: number): Promise<number> {\n    // Get TI-related risks for this service\n    const tiRisks = await this.db.prepare(`\n      SELECT AVG(r.risk_score) as avg_score, COUNT(*) as count\n      FROM risks r\n      WHERE r.category = 'cybersecurity' AND r.status = 'active'\n        AND (r.description LIKE '%service%' OR r.ti_enriched = TRUE)\n    `).bind().first();\n\n    return (tiRisks?.avg_score as number) || 0;\n  }\n\n  private async calculateOperationalRisk(serviceId: number): Promise<number> {\n    const service = await this.db.prepare(\n      'SELECT risk_score FROM services WHERE id = ?'\n    ).bind(serviceId).first();\n\n    return (service?.risk_score as number) || 0;\n  }\n\n  private async calculateComplianceRisk(serviceId: number): Promise<number> {\n    // This would integrate with compliance systems\n    return Math.random() * 100; // Placeholder\n  }\n\n  private async calculateStrategicRisk(serviceId: number): Promise<number> {\n    // This would assess business impact and strategic importance\n    return Math.random() * 100; // Placeholder\n  }\n\n  private async serviceHasTIEnrichment(serviceId: number): Promise<boolean> {\n    const result = await this.db.prepare(`\n      SELECT COUNT(*) as count FROM risks r\n      JOIN risk_ti_mappings rtm ON r.id = rtm.risk_id\n      WHERE r.ti_enriched = TRUE\n    `).bind().first();\n\n    return (result?.count as number) > 0;\n  }\n\n  private async createRiskTIMapping(riskId: number, indicatorId: number, relevance: number): Promise<void> {\n    await this.db.prepare(`\n      INSERT OR IGNORE INTO risk_ti_mappings (risk_id, ti_indicator_id, relevance_score, mapping_reason)\n      VALUES (?, ?, ?, 'auto-mapped by enhanced risk engine')\n    `).bind(riskId, indicatorId, relevance).run();\n  }\n\n  private async logRiskActivity(riskId: number, activity: string, notes: string): Promise<void> {\n    // This would log to a risk activity/audit table\n    console.log(`Risk ${riskId} - ${activity}: ${notes}`);\n  }\n\n  private extractSearchTerms(risk: any): string[] {\n    const text = `${risk.title} ${risk.description}`.toLowerCase();\n    const terms: string[] = [];\n\n    // Extract CVE patterns\n    const cveMatches = text.match(/cve-\\d{4}-\\d{4,}/g);\n    if (cveMatches) {\n      terms.push(...cveMatches);\n    }\n\n    // Extract technology keywords based on category\n    const techKeywords = {\n      cybersecurity: ['vulnerability', 'exploit', 'malware', 'breach', 'attack'],\n      operational: ['performance', 'capacity', 'availability', 'outage'],\n      compliance: ['audit', 'control', 'regulation', 'policy'],\n      strategic: ['vendor', 'supplier', 'regulatory', 'market']\n    };\n\n    const categoryKeywords = techKeywords[risk.category as keyof typeof techKeywords] || [];\n    categoryKeywords.forEach(keyword => {\n      if (text.includes(keyword)) {\n        terms.push(keyword);\n      }\n    });\n\n    return [...new Set(terms)];\n  }\n\n  private determineExploitStatus(indicators: any[]): string {\n    const activeExploits = indicators.filter(i => i.exploit_available && i.exploit_maturity === 'active');\n    if (activeExploits.length > 0) return 'active';\n    \n    const availableExploits = indicators.filter(i => i.exploit_available);\n    if (availableExploits.length > 0) return 'available';\n    \n    return 'none';\n  }\n\n  private normalizeLikelihood(likelihood: string): 'high' | 'medium' | 'low' {\n    switch (likelihood.toLowerCase()) {\n      case 'very high':\n      case 'high':\n        return 'high';\n      case 'medium':\n      case 'moderate':\n        return 'medium';\n      case 'low':\n      case 'very low':\n      default:\n        return 'low';\n    }\n  }\n\n  private normalizeImpact(impact: string): 'high' | 'medium' | 'low' {\n    switch (impact.toLowerCase()) {\n      case 'very high':\n      case 'high':\n      case 'critical':\n        return 'high';\n      case 'medium':\n      case 'moderate':\n        return 'medium';\n      case 'low':\n      case 'very low':\n      default:\n        return 'low';\n    }\n  }\n}